| Лабораторная работа №1 | M3104                        | АОВС |
| ---------------------- |------------------------------| ---- |
| Представление чисел    | Заимкин Святослав Валерьевич | 2024 |

## Инструментарий
> При наличии переписываем из ТЗ, если требуется, указываем свои данные (компилятор/стандарт и т.д.). 

## Что реализовано
> Вариант 1. Реализована normal версия работы: перевел программу из с в ассемблер RV32. Также Посчитал lru-cache и plru-cache.
> Также дописал некоторые функции, о которых будет сказано дальше, чтобы перевести ассемблер в машинный код.

## Результат работы на тестовых данных: [ссылка на последний успешный action с актуальными данными](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-zxcbank/actions/runs/9116214943)

# Описание:
    
| Параметры                | Системы                     |
|--------------------------|-----------------------------|
| MEM_SIZE                 | 262144 байт                 |
| ADDR_LEN                 | **18 бит**                  | 
| Представление чисел      | **look-through write-back** | 
| Политики вытеснения кэша | **LRU и bit-pLRU**          | 
| CACHE_WAY                | **4**                       |
| CACHE_TAG_LEN            | 8 бит                       |
| CACHE_INDEX_LEN          | 5 бит                       |
| CACHE_OFFSET_LEN         | 5 бит                       | 
| CACHE_SIZE               | 4096 байт                   |
| CACHE_LINE_SIZE          | **32 байт**                 |
| CACHE_LINE_COUNT         | 128                         |
| CACHE_SETS               | **32**                      |

Подсчет параметров системы:
MEMSIZE = 2 ** ADDR_LEN,
CACHE_INDEX_LEN = log(CACHE_SETS) = 5 бит,
CACHE_LINE_COUNT = CACHE_SETS * CACHE_WAY = 128,
CACHE_OFFSET_LEN = log(CACHE_SIZE) = 5 бит,
CACHE_SIZE = CACHE_LINE_SIZE * CACHE_LINE_COUNT = 4096 байт.

###  Раздел, в котором вы описываете свою реализацию:

# >` ISA:`

Я посмотрел ABI-названия регистров из calling convention. Далее посмотрел сами команды RV32I и RV32M, как они устроены и тд. Сейчас постараюсь объяснить как
я переводил в asm:
Для работы циклов необходимо было завести переменную-итератор: 
    `addi t2, zero,  0` - в регистр t2 я положил сумму значения в zero (там всегда 0)
    и константы (т.е. 0).
    `addi t2, t2, 1+` - инкрементировал значение, которое лежит в этом регистре
    `blt t2, s3, -80` - услонвый переход: т.е. если в t2 лежит значение меньшее s3, то мы переставляем PC (programm-counter) на 80 байт назад.
Для того, чтобы корректно заполнять массивы, я завел регистры, которые изначально хранят адрес, указывающий на начала этих массивов, далее в зависимости
от размера массива инкрементировал на 1, 2 или 4 значение адреса:
    `lui t4, 0x900` - это адрес начала массива b, т.е. в регистр t4 я загрузил 0х900 со сдвигом на 12, (в данном случае воспользоваться addi не получилось)
поэтому далее приходлилось делать сдвиг обратно.
    `srli t4, t4, 12` - помещает в регистр t4, значение из t4 сдвинутое на 12 бит вправо.
Чтобы загружать значения в память я использовал lb для загрузки 1 байта, lh - для двух и lw для 4-х байт соответственно.
    `lh a4, 0, s9` - в регистр a4, загружается значение по адресу, который хранится в s9.
    `sw t5, 0, a5` - в адрес, который хранится в t5 загружается значение из регистра a5.

# > `asm->binary :`

После [парсинга команд ассемблера](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-zxcbank/blob/6b89906b572af1b15b81b0f29d8e26c74edb80a2/include/processor.cpp#L35) у меня получался вектор объектов AssmblerInstruction. Этот объект представляет из себя строки для команды
и трех операндов. Если команда на 2 операнда, то в третьей лежит мусор, который я не буду использовать. Поэтому оставалось просто операнды
перевести в регистры, числа или числа из памяти. Это реализуют [getRegNum()](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-zxcbank/blob/6b89906b572af1b15b81b0f29d8e26c74edb80a2/include/regesters.cpp#L8) с помощью соответствующего enum'а или функции [convert](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-zxcbank/blob/6b89906b572af1b15b81b0f29d8e26c74edb80a2/include/RiskVcommand.hpp#L49), которая
переводит числа из 2сс и 16сс в 10сс. После того, как операнды переведены в числовой вид, оставалось просто взять опкоды и типы команд, и аккуратно
записать в соответствующий файл. Этот функционал представлен [здесь](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-zxcbank/blob/6b89906b572af1b15b81b0f29d8e26c74edb80a2/include/processor.cpp#L146)
Также надо было поменять порядок байт (берем по два, внутри их не разворачиваем, и меняемих местами 1 => 4, 2 => 3).
Этот функционал представлен [здесь](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-zxcbank/blob/6b89906b572af1b15b81b0f29d8e26c74edb80a2/include/processor.cpp#L141).
Использование самой функции представлено [здесь](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-zxcbank/blob/6b89906b572af1b15b81b0f29d8e26c74edb80a2/include/processor.cpp#L108).
Также же хотел добавить, что реализованы метки. Хотя в итоговом asm файле я их не использую по причине того, что сложно делать дебаг. 
Изначально я делал с ними, так как мне казалось, что так проще, но потом я отказался от них, но все-таки решил доделать начатое.

# `Cache:`

**Классы - LRU и PLRU**. Эти классы считают, вхождения в кеш и вытеснения из кеша по соотвествующим политикам. Эти классы управляют классами CacheLine и 
bitCacheLine соответственно. Для работы кеша заведена `global_time_utc0`, выполняет функцию виртуального времени. Она инкрементируется при обработке 
каждой новой команды. Также есть метод `IsRamUsing`, он отвечает на вопрос: будет ли команда обращаться в память. Если да, то cache_access для PLRU и LRU
инкрементируется.
**Отслеживание попаданий**. В каждом классе есть метод, отвечающий за попадание в конкретную линию `checkLRU` и `checkPLRU`. Они возращают bool.
Если попадание было, то внутри `execute` увеличит попадания в кеш. Когда мы обращаемся к нескольким кешлиниям - необходимо попадания всех, для того
чтобы зачесть попадание.
    

# > `Результат работы программы при разных аргументах командной строки`
##### --replacement 0 --asm rv32.asm --bin mama.bin
`LRU     hit rate: 99.1250% 
pLRU    hit rate: 99.4046%`

##### --replacement 1 --asm rv32.asm --bin mama.bin
`LRU     hit rate: 99.1250%`

##### --replacement 2 --asm rv32.asm --bin mama.bin
`pLRU    hit rate: 99.4046%`
